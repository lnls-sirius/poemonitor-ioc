PREFIXO:PwrState-Sel (Off/On) (escrita sob demanda)
PREFIXO:PwrState-Sts (Off/On) (leitura uma vez por segundo)
PV  do STATUS                 (status) -> mostrar os 5 estados possiveis

Na inicialização do IOC: ler o estado atual da interface e atribuir ele às duas PVs acima.

====================================================
status possiveis a serem regastados das entradas POE
====================================================
• Searching: The port is trying to detect a PD connection. (PPDS_SEARCHING)
• Delivering: The port is delivering power to a PD.        (PPDS_DELIVERING)
• Disabled: On the indicated port, either PoE support is disabled or PoE power is enabled (PPDS_DISABLED)
but the PoE module does not have enough power available to supply the port's power
needs.
• Fault: The switch detects a problem with the connected PD. (PPDS_FAULT)
• Other Fault: The switch has detected an internal fault that prevents it from supplying (PPDS_OTHERFAULT)
power on that port.
---------------------------------------------------------------------------------------------------
pv -> delivering or not delivering -> basicamente ON ou OFF
pv -> complete status              -> Mostra o estado completo, mais detalhado (explicação do q é o estado inserida na PV?)

verificar se da para pegar stats de 3 portas em 1 segundo -> é possivel, foi realizado um teste para tentar obter 10 amostras de cada
em 1 segundo e demorou 1.127 segundos.

usar pykaspy para criar as PVs -> criar todas as pvs

arquivo com listagem de configuração
de cada dispisitivo -> o IOC deverá ler esse arquivo de configuração e saber através dele quais são todos os
dispositivos que devem ser monitorados, esse arquivo deve conter as seguintes informações de cada dispositivos
    ip do switch , (comunicação com o switch)
    numero da porta,-> (comunicação com o switch)
    niome do dispostiivo -> (prefixo da PV)


Fazer thread para buscar na API o valor e traduzir esse valor para oq mostrar na PV
    -> criar as filas
    -> criar toda a thread scan
        -> criar os eventos para inserir os gets periodicos

-> criar as thread process para cada fila
    ->executar leitura de valores (ok)
    ->executar escrita de valores
        ->Fazer a inserção da request de escrita (mover o cpodigo que esta no
        lugar errado como sinalizado pelos comentarios)
        ->executar o request
fazer pela função write a permissão de escrita na devida pv, e isso faz com que ao invés de alterar naquele momento o valor da pv
ele insira uma requisição de escrita TUPLA -> ("NOME DA REQUISIÇÃO", VALOR) na fila do respectivo switch que dps será processada pela thread process
e ai sim alterado seu valor pelo valor requisitado

testar colocar um alarme nop set param e ver oque da
    -> IMPORTANTE-> VALOR 10 DE ALARM (TIMEOUT) é o comumente usado para qnd a PV está desconectado

definir valores iniciais para PV de seleção(put)
TESTAR ELAS

OQUE ACONTECE SE O SWITCH FOR ESETADO, OS VALORES DAS PVS FICAM INCONSISTENTES?
    -> isso ja foi tratado com a atualização da PV de seleção juntamente com a PV de status em todo processo de scan

inserir valores de alerta para as PVs

Concertar a obtenção da PV seletora, ela é apenas para saber qnd foi escrito ou não. INiciar uma vez no scan e dps não mais

USAR A CLASSE SESSION DA BIBLIOTECA REQUESTS NO LUGAR DA CLASSE CRIADA POR MIM ARUBAREQUESTER (Faz mais sentido)
    ->substituir todos os usos
    ->deletar a classe do código

COISAS PARA DISCUTIR
    -> LIMITE DO TAMANHO DA FILA PODE SER UM PROBLEMA??? -> NÃO ME AGRADA ESSA SOLUÇÃO NEM UM POUCO <- naverdade não faz sentido eu ficar escaneando quando
    o dispositivo está offline, logo faz sentido travar a thread de scan referente ao switch desconectado.
    -> SE ESTIVER DESCONECTADO JOGAR FORA REQUISIÇÕES DE PUT???
    -> POSSO CONTROLAR ATRAVÉS DE OUTRA FILA QUEM ESTÁ CONECTADO E QUEM ESTÁ DESCONECTADO, EVITANDO O PROBLEMA DE RACE CONDITION
    -> AO INVÉS DE GUARDAR O COOKIE E RESETAR SÓ ELE, VER UM COMANDO QUE SEJA POSSÍVEL EXCLUIR TODOS OS DADOS DE SESSÃO, AFINAL SÓ EXISTE UMA CLIENT

colocar o logout no requester
    -> qualquer exeção gerada no meio da conexão , que não seja connection lost , requisitar um logout
    -> em casos de perda de conexão, como tratar o logout???
        ->para a inserção de requisições na fila, limpa as filas?
        -> IDEIA: Configurar o timeout de seção do switch para valores pequenos, considerando q sempre será realizada requisições em curto periodo de temopo
        ele não deve ocorrer durante um funcionamento comum
        ->tratar excessão de timeout de chamada
            -> isso deve ser feito apenas nos envios de put da PV de seleção, pois as outras são lidas periodicamente, caso aconteça o timeout do put
                deve-se inserir um alerta na PV
    -> Fazer o código se recuperar de perdas de conexão

colocarr nome do autor

indicar versão do python usada

CRIAR DINAMICAMENTE AS PVS BASEADAS NO ARQUIVO .CONF e incluir os nomes das variaveis passiveis de serem escritas na função write de maneira dinamica

Coisa para concertar
    ->Setar as varias -SEL apenas no boot do IOC, não fazer mais isso quando recupera CONEXÃO -> ok
    -> parar de fazer reenvio e considerar que quando der 1 timeout, perdeu a conexão -> ok
        ->Sempre que ocorre um timeout é necessário que seja definido os alarmes para as respectivas PVs, já que essa requisição já foi removida
            da fila e não entrara na seção referente ao processamento de requisição desconectada -> ok
            -> isso pois a desconexão pode ocorrer durante um momento que esteja dentro do if(connected == true)
    -> caput -> deve setar o parametro antes mesmo de saber se a request deu certo ou não, em caso de dar errado, sinalizar a PV com alerts -> ok
    -> parar de travar a scan thread qnd perder conexão, deixar ela rodando enquanto as requisições são consumidas e são tratadas de maneira diferente
        por estar DESCONECTADO -> ok

######PROBLEMA, PQ ESTÁ GASTANDO TANTA MEMÓRIA ESSE PROGRAMA????####################
    ->RESOLVIDO -> ERA CAUSADO PELA CHAMADA SimpleServer() DEVIDO A VARIAVEL DE AMBIENTE DO EPICS QUE DEFINE UM TAMANHO BASICO PARA RECEBIMENTO
        DE PVS DO TIPO VETOR
Tentar reduzir mais o consumo de memória RAM -> no momento de import aparentemente está acontecendo um alto consumo de RAM q dps fica constante

tratar overflow no número de sessões se necessário -> testar isso <- COM O MECANISMO DE RESET GERAL ACHO QUE NÃO PRECISARÁ <- Não encontrei um COMANDO
que faça isso, contudo reduzi para 2 minutos o tempo de logout de sessão ociosa

setar um timer qnd logar para garantir que o switch vai estar ligado, pq ele consegue conectar antes de disponibilizar energia, podendo prejudicas
os valores salvos???? <- acredito acontecer "raramente" isso

ANALISAR A LEITURA INICIAL DAS PVs -SEL

DESENHAR O DIAGRAMA DA ARQUITETURA E SUBIR NO GIT -> inserir na descrição do código esse link

Analisar se é  um problema quando está offline do switch logo no boot a variavel -Raw vir sem valor nenhum apenas com os alarms

Documentar a versão dos outros módulo (requests e etc)

SUBIR COMO UM CÓDIGO DIFERENTE DO CONTROLADOR POE
    -> PASSAR A LIMPO  E ORNGANIZAR AS INFORMAÇÕES NO CADERNO
    ->TESTAR USO DA API REST SEM LOGIN SENDO QUE HÁ UM USUÁRIO CRIADO NO SWITCH -> COnclusão: é necessário o login
    -> Não será necessário mais fazer login, portanto remover todas as partes referentes a isso. O funcionamento do IOC então ser dará
    simplesmente tentado fazer a requisião e se der timeout sinalizando com os ALERTAS que deu errados, ou se der certo, sinaliza o status
    ->Averiguar sobre a inicialização das variaveis SEL no boot do IOC -> Deixar todas zeradas sempres? COncluir o estado baseado nas Pvs
        de status??? Não vamos perder o histórico de escritas que desejavamos? -> CONCLUIMOS QUE SERÁ REALIZADA A DEDUÇÃO
    -> Realizar todos os testes novamente depois da nova alteração
    -> ATUALIZAR OS DIAGRAMAS
    -> DOCUMENTAR O SIGNIFCADO DOS ALARMES EM CADA CASO

->ERRO GRAVE NA FUNÇÃO getQueueIdByDeviceName DO SWITCH-CONFIG-READER
    ->ELA FUNCIONA APENAS PARA DEBUG, ESTA USANDO NOME FIXO DA PV, VERIFICAR A ALTREÇÃO PARA NOME DINAMICO VIA PARAMETRIO
    -> ERRO NO LOOP DE GERAÇÃO DINAMICA DE TELAS
COnfigurar o servidor VNC no meu pc
->ENVIO DO VALOR VIA MACROS DO PYDM PARA A OUTRA TELA, OBTER ESSE VALOR DENTRO DE UM WIDGET, NO CASO O TEXTO DO HEADER E USAR ESSE TEXTO
PARA PEGAR DINAMICAMENTE OS DADOS NO ARQUIVO -> ANALISAR NÃO USAR O RELATED BUTTON E SIM O PUSH BUTTON

    ->APAGAR LINHA DE CODIGO COMENTADAS RESPECTIVAS AOS SIGNALS
    ->NÃO ESQUECER DE MUDAR DINAMICAMENTE O LABEL EMCIMA DA TABELA PARA O NOME DA SALA

    ->tela do pydm
        ->montagem da tela DINAMICAMENTE
        ->FAZER O ON/OFF BUTTON, OUUUUUUUU CHECKBOX
        -> QUando no menu clica em um botão, envia o ip da sala para a outra tela via sinal e baseado nesse IP, pega om arquivo de config
            e cria os elementos de vizualização ou analisar o uso do widget templeateRepeater já que parece que posso enviar dinamicamente,
            uma lista de objetos e seus respectivos macros, fazendo com que eu possa controlar tudo pelo menu apenas
        -> Seleciona a sala e o switch? ou só a sala e ja mostra separadamente todos os switchs da sala (Parece mais simples, rápido e menos passo a passo
            pro operador) -> aqui entra a parte da tradução de ip para nome de sala e também para número do switch
                ->PROTÓTIPO NO CADERNO MOSTRA A IDEIA

    ->MONTAR OS ARQUIVOS DE CONFUGRAÇÃO DENOVO , PENSANDO NA ESTRUTURA DO SIRIUS OS ATUAIS SÃO APENAS TESTE
    ->renomear arquivo de configuração dos IOCs para switch.config

    fazer um laucher da GUI???

    -> reduzir o tempo de timeout para um valor próximo ao q uma requisição demora
        ->fazer teste do tempo de resposta de cada switch, qnd ele esta com conexão ssh aberta ou não,fazer teste considerando o switch que está no sirius,
            pensar tbm sobre o estresse no dispositiovo que está rodando o IOC, de ele demorar para processar a resposta, contudo considerando que
            será um servidor poderoso não é para haver muitos problemas
        -> timeouts maiores influenciam diretamente no preenchimento excessivo da fila de requisições, oque fazer, velocidade do scan ser proporcional
    	ao tempo do timeout??? Limitar número maximo de requests do tipo scan ??? -> SÓ INSERIR UMA REQUEST SCAN NA FILA SE ELA NÃO EXISTIR LÁ
    fazer teste enm uma situação real no Sirius
        -> montar o arquivo de configuração como anotado no caderno sobre os ips e portas
        -> verificar qual dispositivo é o do switch 10.128.101.11 -> Camera prof.Rubens Ignorar
        ->pegar os nomes dos dispositivos? (Não necessário para o primeiro teste mas seria interessante já ir atrás disso)

    Atualizar documentação dos padrões de arquivos de configuração no git

    ->NOME DAS PVs
        ->Confirmar com a Patricia um nome provisório para as PVs das placas contadoras

        ->Verificar nome das PVs e arrumar os arquivos de configuração em relação aos novos nomes das PVs


Criar a imagem docker -> usar o repositório hub.docker.com/_/python
    -> usar imagem 3.6.5 strech (para Debian mais recente) -> OK
        ->será necessário instalar pcaspy,requests, pip
    -> durante instalação do pcaspy é necessário definir 2 variasveis de ambiente -> OK
        EPICS_BASE... = . pip install pcaspy
        2ª variaveis = linux-x86_64 pip install pcaspy
    ->A base epics instalada deve ser a ,6 no final e n a .5 como mostrado da wikiSirius -> OK

    CORRIGIR TODOS OS LUGARES QUE ESTÁ ESCRITO ENVIROMENT PARA environment (TEM UM N ANTES DO M)

    Fazer o compose file -> TEORICAMENTE FINALIZADO, VER COMO TESTAR , QUAL COMANDO RODAR??? CONFERIR SE ESTÁ TUDO CERTO
    -> IOC deve se encontrar fora do ambiente criado do Docker, para sempre que for alterado o código não seja necessário remontar a imagem
        e sim apenas reiniciala
        ->Pasta externa ao container é mapeado dentro dele para que seja acessivel um arquivo de fora pelo container, logo permite que ele execute
        o IOC presente em uma pasta externa, deixando o container mais modular

    IOC só está funcionando quando é buildado e iniciado direto pelo docker compose
        ->ISSO FAZ SENTIDO POIS É NO DOCKER COMPOSE QUE SE INICIA O VOLUME

    subir imagem docker criada para o projeto no docker hub

    adaptar código do compose file para código funcional no swarm -> cRIAR UM NOVO ARQUIVO, DEIXAR TANTO O COMPOSE QUANTO O SWARM NO REPOSITÓRIO

    depois do teste voltar configurações ao normal -> config file do ioc para switches e o caminho do compose file tbm
    volume -> "/storage/misc/repository/poemonitor-ioc/src/ioc/withoutApiLogin:/usr/local/poemonitor-ioc/"

    rodar o swarm no servidor e validar seu funcionamento (IOC ok?? Alterações plug and play tbm???)

    montar README da pagina dos diagramas
        ->montar tutorial de como excluir dados ou adicionar nos arquivos de configuração

    fazer documento explicando como está no caderno sobre como funciona o container docker criado
    e quais são as minimas alterações necessárias de serem realizadas para aplicar qualquer update de versão do ioc

    Adicionar mais informações no read me do github
        ->uam coisa a falar é explicar a diferença dos arquivos contidos em cada pasta
        ->Indicar que para mais informações sobre os status da PV raw e seus significados, acessar a documentação do switch
        ->Explicar que existem arquivos duplicados dentro das pastas exatamente paraas coisas funcionarem standlone (explicar que existe essa necessidade)
            pois o IOC funciona sem a interface gráfica de controle
        ->documentar a necessidade de haver um cópida do arquivo de configuração dentro da pasta dos displays da GUI (devido eles funcionarem standalone)
        ->explicação da dinamicidade das telas baseado nos 2 arquivos de confugração
        ->Explicação do passo a passo para inserir ou deletar uma nova sala ou switch nos arquivos de configuração
        ->Explicar esquema de ID das salas de racks e conectividade no arquivo rooms.config

    #####PAREI AQUI #######

    adicionar PVs no archivers

    terminar a montagem da interface gráfica do menu principal

    verificar como avisar no status e trocar de cor para rosa -> contatar a Lais

    DELETAR TODOS CÓDIGOS DE DEBUGS -> control f DEBUG

    ATUALIZAR DIAGRAMAS ALTERADOS

    fazer explicação com a GUI de como interpretar os alarmes

    ->Pensar em cada caso de falha e explicar como são alarmados e os signifcados, usar imagens da tela criada para demosntrar???
        ->Acho interessante mostrar as telas para explicar como interpretar os feedbacks visuais
            ->tirei uma foto de um caso que expressa bem isso

    -> anotar considerações futuras para o projeto
    NECESSIDADE DE SER CRIPTOGRAFADA OS DADOS DE AUTENTICAÇÃO NO SWITCH
    realizar o teste de timeout para a estrutura usando autenticação nos switches (NÃO TESTADA POIS NÃO FOI A APLICADA NO MOMENTO)

    RENOVAR O LINK DOS DIAGRAMAS NO CABEÇALHO DO CÓDIGO, LINKS SOBRESSALENTE DEVIDO A MUDANÇA DO FORMATO DE DIRETÓRIO USADO

    problemas durante a criação de telas dinamicas com pydm para reportar a Lais

        -> Não consegui passar valor via relatedDisplayButton
        -> Quando fiz um funcionamento similiar so relatedDisplayButton com apenas pushButtons(logo q o usuario clicava eu
         criava io objeto display dinamico) os alarms paravam de funcionar
         ->Solução foi usar shellCode button e chamar passando argc argv a tela de display
